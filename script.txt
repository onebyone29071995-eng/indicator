//@version=6
indicator("Кластеры экстремумов (только последние 10) v6 ИСПРАВЛЕННЫЙ", overlay=true, max_lines_count=200, max_labels_count=500)

// ========== ВХОДНЫЕ ПАРАМЕТРЫ ==========
leftBars = input.int(5, "Левый бар для поиска пивотов", minval=1, group="Поиск экстремумов")
rightBars = input.int(5, "Правый бар для поиска пивотов", minval=1, group="Поиск экстремумов")
lookback_bars = input.int(200, "Количество баров для поиска абсолютных экстремумов", minval=10, maxval=1000, group="Поиск экстремумов") 

cluster_threshold = input.float(0.01, "Порог кластеризации (%)", minval=0.01, maxval=5.0, group="Кластеризация") / 100
min_cluster_size = input.int(2, "Минимальный размер кластера", minval=2, group="Кластеризация")
use_only_recent = input.bool(true, "Только последние экстремумы", group="Кластеризация")
recent_extremums_count = input.int(20, "Количество последних экстремумов", minval=2, maxval=50, group="Кластеризация")
recalc_bars = input.int(50, "Пересчёт кластеров каждые N баров", minval=10, maxval=1000, group="Кластеризация")

offset_percent = input.float(0.03, "Процент отступа для offset линий", step=0.01, minval=0.01, maxval=10.0, group="Offset линии")

bars_offset = input.int(1, "Баров для подтверждения запила", minval=1, maxval=10, group="Логика запилов")
enable_breakthrough_logic = input.bool(true, "Включить логику запилов", group="Логика запилов")
show_breakthrough_labels = input.bool(true, "Показать лейблы запилов", group="Логика запилов")
enable_offset_alerts = input.bool(true, "Включить оповещения касания offset линий", group="Логика запилов")
max_breakthroughs = input.int(2, "Количество запилов для удаления кластера", minval=1, maxval=10, group="Логика запилов")

auto_scale_enabled = input.bool(true, "Включить автомасштабирование", group="Автомасштабирование")
scale_factor = input.float(1.0, "Коэффициент масштабирования", minval=0.1, maxval=5.0, step=0.1, group="Автомасштабирование")
dynamic_line_width = input.bool(true, "Динамическая ширина линий", group="Автомасштабирование")
dynamic_label_size = input.bool(true, "Динамический размер лейблов", group="Автомасштабирование")

show_absolute_lines = input.bool(true, "Показать абсолютные экстремумы", group="Отображение")
show_cluster_lines = input.bool(true, "Показать линии кластеров", group="Отображение")
show_offset_lines = input.bool(true, "Показать offset линии", group="Отображение")
show_fill = input.bool(true, "Заливка между offset линиями", group="Отображение")
show_cluster_labels = input.bool(true, "Подписи размера кластеров", group="Отображение")

// ========== ПОЛЬЗОВАТЕЛЬСКИЕ ТИПЫ ==========
type ExtremumData
    float price
    int bar_index
    int bar_time
    bool is_clustered

type ClusterData
    float avg_level
    float upper_offset_level
    float lower_offset_level
    int cluster_size
    bool is_high
    string level_id
    int start_bar
    int end_bar
    int start_time
    int end_time
    bool upper_offset_touched
    bool lower_offset_touched

type BreakthroughData
    string level_id
    float level_price
    int cluster_size
    bool is_high
    int breakthrough_count
    int pending_check_bar
    bool is_pending
    line cluster_line
    line upper_offset_line
    line lower_offset_line
    linefill offset_fill

type ScaleData
    float price_range
    int visible_bars
    float current_volatility
    float zoom_level

// ========== ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ==========
var line absolute_high_line = na
var line absolute_low_line = na
var array<ExtremumData> high_extremums = array.new<ExtremumData>()
var array<ExtremumData> low_extremums = array.new<ExtremumData>()
var array<line> cluster_lines = array.new<line>()
var array<line> upper_offset_lines = array.new<line>()
var array<line> lower_offset_lines = array.new<line>()
var array<linefill> offset_fills = array.new<linefill>()
var array<label> cluster_labels = array.new<label>()
var array<ClusterData> active_clusters = array.new<ClusterData>()

var array<BreakthroughData> breakthrough_tracker = array.new<BreakthroughData>()
var array<label> breakthrough_labels = array.new<label>()
var ScaleData current_scale = na

// Глобальные переменные для алертов всех запилов
var array<bool> high_breakthrough_alerts = array.new<bool>()
var array<bool> low_breakthrough_alerts = array.new<bool>()

// ========== ФУНКЦИИ АВТОМАСШТАБИРОВАНИЯ ==========
calculate_scale_parameters() =>
    visible_high = ta.highest(high, 100)
    visible_low = ta.lowest(low, 100)
    price_range = visible_high - visible_low
    visible_bars = math.min(100, bar_index + 1)
    atr_value = ta.atr(14)
    volatility = atr_value / close
    zoom_level = price_range / close
    ScaleData.new(price_range, visible_bars, volatility, zoom_level)

get_scaled_line_width(base_width) =>
    if not auto_scale_enabled or not dynamic_line_width
        base_width
    else
        scale_data = current_scale
        if na(scale_data)
            base_width
        else
            zoom_factor = math.max(0.5, math.min(3.0, 1.0 / math.sqrt(scale_data.zoom_level * 100)))
            scaled_width = math.round(base_width * zoom_factor * scale_factor)
            math.max(1, math.min(10, scaled_width))

get_scaled_label_size(base_size_str) =>
    if not auto_scale_enabled or not dynamic_label_size
        if base_size_str == "tiny"
            size.tiny
        else if base_size_str == "small"
            size.small
        else if base_size_str == "normal"
            size.normal
        else if base_size_str == "large"
            size.large
        else
            size.small
    else
        scale_data = current_scale
        if na(scale_data)
            size.small
        else
            zoom_factor = 1.0 / math.sqrt(scale_data.zoom_level * 100)
            volatility_factor = math.max(0.7, math.min(1.5, scale_data.current_volatility * 20))
            combined_factor = zoom_factor * volatility_factor * scale_factor
            if combined_factor < 0.7
                size.tiny
            else if combined_factor < 1.0
                size.small
            else if combined_factor < 1.5
                size.normal
            else
                size.large

get_line_extension_distance() =>
    if not auto_scale_enabled
        50
    else
        scale_data = current_scale
        if na(scale_data)
            50
        else
            base_extension = 50
            bars_factor = math.max(0.5, math.min(2.0, scale_data.visible_bars / 50.0))
            math.round(base_extension * bars_factor * scale_factor)

get_label_offset_distance() =>
    if not auto_scale_enabled
        25
    else
        extension_distance = get_line_extension_distance()
        math.round(extension_distance * 0.5)

// ========== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ==========
get_time_by_bar_index(bar_idx) =>
    bars_back = bar_index - bar_idx
    if bars_back < 0
        time
    else if bars_back > 5000
        time[4999]
    else
        time[bars_back]

clear_cluster_graphics_selectively() =>
    if array.size(cluster_lines) > 0
        for i = 0 to array.size(cluster_lines) - 1
            line.delete(array.get(cluster_lines, i))
    array.clear(cluster_lines)
    
    if array.size(upper_offset_lines) > 0
        for i = 0 to array.size(upper_offset_lines) - 1
            line.delete(array.get(upper_offset_lines, i))
    array.clear(upper_offset_lines)
    
    if array.size(lower_offset_lines) > 0
        for i = 0 to array.size(lower_offset_lines) - 1
            line.delete(array.get(lower_offset_lines, i))
    array.clear(lower_offset_lines)
    
    if array.size(offset_fills) > 0
        for i = 0 to array.size(offset_fills) - 1
            linefill.delete(array.get(offset_fills, i))
    array.clear(offset_fills)
    
    if array.size(cluster_labels) > 0
        for i = 0 to array.size(cluster_labels) - 1
            label.delete(array.get(cluster_labels, i))
    array.clear(cluster_labels)
    
    array.clear(active_clusters)

preserve_breakthrough_data() =>
    preserved_breakthroughs = array.new<BreakthroughData>()
    if array.size(breakthrough_tracker) > 0
        for i = 0 to array.size(breakthrough_tracker) - 1
            data = array.get(breakthrough_tracker, i)
            preserved = BreakthroughData.new(data.level_id, data.level_price, data.cluster_size, data.is_high, data.breakthrough_count, data.pending_check_bar, data.is_pending, na, na, na, na)
            array.push(preserved_breakthroughs, preserved)
    preserved_breakthroughs

restore_breakthrough_data(preserved_data) =>
    array.clear(breakthrough_tracker)
    if array.size(preserved_data) > 0
        for i = 0 to array.size(preserved_data) - 1
            array.push(breakthrough_tracker, array.get(preserved_data, i))

should_recalculate_clusters() =>
    base_condition = (bar_index % recalc_bars == 0 and barstate.isconfirmed) or barstate.islast
    
    significant_price_change = false
    if bar_index > 50
        price_change_percent = math.abs(close - close[10]) / close[10]
        significant_price_change := price_change_percent > 0.02
    
    base_condition or significant_price_change

limit_graphics_objects() =>
    max_lines = 100
    max_fills = 50
    max_labels = 50
    
    while array.size(cluster_lines) > max_lines
        old_line = array.shift(cluster_lines)
        if not na(old_line)
            line.delete(old_line)
    
    while array.size(offset_fills) > max_fills
        old_fill = array.shift(offset_fills)
        if not na(old_fill)
            linefill.delete(old_fill)
    
    while array.size(cluster_labels) > max_labels
        old_label = array.shift(cluster_labels)
        if not na(old_label)
            label.delete(old_label)

limit_array_size(extremums) =>
    if use_only_recent
        while array.size(extremums) > recent_extremums_count
            array.shift(extremums)
    else
        max_safe_size = 200
        while array.size(extremums) > max_safe_size
            array.shift(extremums)

find_absolute_extremums() =>
    abs_high = high[0]
    abs_low = low[0]
    max_lookback = math.min(lookback_bars - 1, bar_index, 4999)
    for i = 0 to max_lookback
        if high[i] > abs_high
            abs_high := high[i]
        if low[i] < abs_low
            abs_low := low[i]
    [abs_high, abs_low]

generate_level_id(avg_price, is_high) =>
    price_str = str.tostring(math.round(avg_price * 10000) / 10000)
    type_str = is_high ? "HIGH" : "LOW"
    price_str + "_" + type_str

// ========== ИНИЦИАЛИЗАЦИЯ МАССИВОВ АЛЕРТОВ ==========
initialize_alert_arrays() =>
    array.clear(high_breakthrough_alerts)
    array.clear(low_breakthrough_alerts)
    for i = 1 to max_breakthroughs
        array.push(high_breakthrough_alerts, false)
        array.push(low_breakthrough_alerts, false)

// ========== ФУНКЦИИ ДЛЯ ЗАПИЛОВ ==========
find_breakthrough_data(level_id) =>
    var BreakthroughData found_data = na
    if array.size(breakthrough_tracker) > 0
        for i = 0 to array.size(breakthrough_tracker) - 1
            data = array.get(breakthrough_tracker, i)
            if data.level_id == level_id
                found_data := data
                break
    found_data

update_breakthrough_data(level_id, level_price, cluster_size, is_high, cluster_line, upper_offset_line, lower_offset_line, offset_fill) =>
    existing_data = find_breakthrough_data(level_id)
    if na(existing_data)
        new_data = BreakthroughData.new(level_id, level_price, cluster_size, is_high, 0, -1, false, cluster_line, upper_offset_line, lower_offset_line, offset_fill)
        array.push(breakthrough_tracker, new_data)
        new_data
    else
        existing_data.cluster_line := cluster_line
        existing_data.upper_offset_line := upper_offset_line
        existing_data.lower_offset_line := lower_offset_line
        existing_data.offset_fill := offset_fill
        existing_data

check_offset_touch(cluster_data) =>
    var bool upper_touch_alert = false
    var bool lower_touch_alert = false
    
    if cluster_data.is_high
        if not cluster_data.upper_offset_touched and high[1] > cluster_data.upper_offset_level and low <= cluster_data.upper_offset_level
            cluster_data.upper_offset_touched := true
            upper_touch_alert := true
        if not cluster_data.lower_offset_touched and low[1] < cluster_data.lower_offset_level and high >= cluster_data.lower_offset_level
            cluster_data.lower_offset_touched := true
            lower_touch_alert := true
    else
        if not cluster_data.upper_offset_touched and high[1] > cluster_data.upper_offset_level and low <= cluster_data.upper_offset_level
            cluster_data.upper_offset_touched := true
            upper_touch_alert := true
        if not cluster_data.lower_offset_touched and low[1] < cluster_data.lower_offset_level and high >= cluster_data.lower_offset_level
            cluster_data.lower_offset_touched := true
            lower_touch_alert := true
    
    reset_threshold = cluster_data.is_high ? (cluster_data.upper_offset_level - cluster_data.lower_offset_level) * 2.0 : (cluster_data.upper_offset_level - cluster_data.lower_offset_level) * 2.0
    
    if cluster_data.is_high
        if cluster_data.upper_offset_touched and close < (cluster_data.upper_offset_level - reset_threshold)
            cluster_data.upper_offset_touched := false
        if cluster_data.lower_offset_touched and close > (cluster_data.lower_offset_level + reset_threshold)
            cluster_data.lower_offset_touched := false
    else
        if cluster_data.upper_offset_touched and close < (cluster_data.upper_offset_level - reset_threshold)
            cluster_data.upper_offset_touched := false
        if cluster_data.lower_offset_touched and close > (cluster_data.lower_offset_level + reset_threshold)
            cluster_data.lower_offset_touched := false
    
    [upper_touch_alert, lower_touch_alert]

check_level_breakthrough(level_price, is_high) =>
    breakthrough_occurred = false
    if is_high
        if low <= level_price and high >= level_price and close > level_price
            breakthrough_occurred := true
    else
        if high >= level_price and low <= level_price and close < level_price
            breakthrough_occurred := true
    breakthrough_occurred

create_breakthrough_label(level_price, cluster_size, is_high, breakthrough_num) =>
    if show_breakthrough_labels
        label_text = if is_high
            str.tostring(breakthrough_num) + "-й запил хай\nУровень: " + str.tostring(level_price, "#.####") + "\nЭкстремумов: " + str.tostring(cluster_size)
        else
            str.tostring(breakthrough_num) + "-й запил лоу\nУровень: " + str.tostring(level_price, "#.####") + "\nЭкстремумов: " + str.tostring(cluster_size)
        
        label_color = if is_high
            breakthrough_num == 1 ? color.lime : (breakthrough_num >= max_breakthroughs ? color.red : color.green)
        else
            breakthrough_num == 1 ? color.orange : (breakthrough_num >= max_breakthroughs ? color.maroon : color.red)
        
        label_style = is_high ? label.style_label_up : label.style_label_down
        label_size = get_scaled_label_size("small")
        
        breakthrough_label = label.new(bar_index, level_price, label_text, color=label_color, textcolor=color.white, style=label_style, yloc=yloc.price, size=label_size)
        array.push(breakthrough_labels, breakthrough_label)

// ========== ИСПРАВЛЕННАЯ ФУНКЦИЯ СКРЫТИЯ КЛАСТЕРОВ ==========
// Найдите в вашем коде функцию safe_hide_cluster_elements() и замените её на эту:

safe_hide_cluster_elements(breakthrough_data) =>
    // Полное удаление графических элементов вместо скрытия
    if not na(breakthrough_data.cluster_line)
        line.delete(breakthrough_data.cluster_line)
    
    if not na(breakthrough_data.upper_offset_line)
        line.delete(breakthrough_data.upper_offset_line)
    
    if not na(breakthrough_data.lower_offset_line)
        line.delete(breakthrough_data.lower_offset_line)
    
    if not na(breakthrough_data.offset_fill)
        linefill.delete(breakthrough_data.offset_fill)
    
    // ИСПРАВЛЕНО: Удаляем элементы из массивов по индексу, а не по сравнению объектов
    // Находим и удаляем соответствующий кластер из active_clusters по level_id
    if array.size(active_clusters) > 0
        indices_to_remove_clusters = array.new<int>()
        for i = 0 to array.size(active_clusters) - 1
            cluster_data = array.get(active_clusters, i)
            if cluster_data.level_id == breakthrough_data.level_id
                array.push(indices_to_remove_clusters, i)
        
        if array.size(indices_to_remove_clusters) > 0
            for i = array.size(indices_to_remove_clusters) - 1 to 0
                index_to_remove = array.get(indices_to_remove_clusters, i)
                array.remove(active_clusters, index_to_remove)
    
    // Очистка связанных лейблов прорывов по координатам
    if array.size(breakthrough_labels) > 0
        indices_to_remove_labels = array.new<int>()
        for i = 0 to array.size(breakthrough_labels) - 1
            breakthrough_label = array.get(breakthrough_labels, i)
            if not na(breakthrough_label)
                label_y = label.get_y(breakthrough_label)
                price_tolerance = breakthrough_data.level_price * 0.001
                if math.abs(label_y - breakthrough_data.level_price) <= price_tolerance
                    label.delete(breakthrough_label)
                    array.push(indices_to_remove_labels, i)
        
        if array.size(indices_to_remove_labels) > 0
            for i = array.size(indices_to_remove_labels) - 1 to 0
                index_to_remove = array.get(indices_to_remove_labels, i)
                array.remove(breakthrough_labels, index_to_remove)
    
    // Обнуляем ссылки в breakthrough_data для предотвращения повторного использования
    breakthrough_data.cluster_line := na
    breakthrough_data.upper_offset_line := na
    breakthrough_data.lower_offset_line := na
    breakthrough_data.offset_fill := na

// ========== ИСПРАВЛЕННАЯ ФУНКЦИЯ КЛАСТЕРИЗАЦИИ С ПРАВИЛЬНОЙ ЛОГИКОЙ ==========
find_clusters(extremums, is_high) =>
    size = array.size(extremums)
    if size < min_cluster_size
        0
    else
        clusters_found = 0
        processed_indices = array.new<int>()
        
        base_i = 0
        while base_i < size
            if not array.includes(processed_indices, base_i)
                base_extremum = array.get(extremums, base_i)
                current_cluster_indices = array.new<int>()
                current_cluster_prices = array.new<float>()
                
                array.push(current_cluster_indices, base_i)
                array.push(current_cluster_prices, base_extremum.price)
                
                changes_made = true
                iteration_count = 0
                max_iterations = 10
                
                while changes_made and iteration_count < max_iterations
                    changes_made := false
                    iteration_count := iteration_count + 1
                    
                    if array.size(current_cluster_prices) > 0
                        current_avg = array.avg(current_cluster_prices)
                        
                        j = 0
                        while j < size
                            if not array.includes(processed_indices, j) and not array.includes(current_cluster_indices, j)
                                test_extremum = array.get(extremums, j)
                                price_diff = math.abs(current_avg - test_extremum.price) / current_avg
                                
                                if price_diff <= cluster_threshold
                                    array.push(current_cluster_indices, j)
                                    array.push(current_cluster_prices, test_extremum.price)
                                    changes_made := true
                            j := j + 1
                
                cluster_size_current = array.size(current_cluster_indices)
                
                if cluster_size_current >= min_cluster_size
                    cluster_bars = array.new<int>()
                    cluster_times = array.new<int>()
                    
                    k = 0
                    valid_points = 0
                    while k < cluster_size_current
                        if k < array.size(current_cluster_indices)
                            idx = array.get(current_cluster_indices, k)
                            if idx >= 0 and idx < array.size(extremums)
                                extremum = array.get(extremums, idx)
                                array.push(cluster_bars, extremum.bar_index)
                                array.push(cluster_times, extremum.bar_time)
                                array.push(processed_indices, idx)
                                valid_points := valid_points + 1
                        k := k + 1
                    
                    final_cluster_size = array.size(current_cluster_prices)
                    if final_cluster_size >= min_cluster_size and valid_points >= min_cluster_size and array.size(cluster_bars) >= min_cluster_size
                        avg_level = array.avg(current_cluster_prices)
                        cluster_count = final_cluster_size
                        
                        min_bar = array.min(cluster_bars)
                        max_bar = array.max(cluster_bars)
                        min_time = array.min(cluster_times)
                        max_time = array.max(cluster_times)
                        
                        upper_offset_level = avg_level * (1 + offset_percent / 100)
                        lower_offset_level = avg_level * (1 - offset_percent / 100)
                        
                        level_id = generate_level_id(avg_level, is_high)
                        
                        cluster_data = ClusterData.new(avg_level, upper_offset_level, lower_offset_level, cluster_count, is_high, level_id, min_bar, max_bar, min_time, max_time, false, false)
                        
                        array.push(active_clusters, cluster_data)
                        
                        var line cluster_line = na
                        var line upper_line = na
                        var line lower_line = na
                        var linefill fill_obj = na
                        
                        if show_cluster_lines
                            cluster_color = is_high ? #ffa500 : #0000ff
                            start_time_line = get_time_by_bar_index(min_bar)
                            extension_distance = get_line_extension_distance()
                            end_time_line = time + (time - time[1]) * extension_distance
                            
                            line_width = get_scaled_line_width(2)
                            
                            cluster_line := line.new(start_time_line, avg_level, end_time_line, avg_level, color=cluster_color, width=line_width, style=line.style_solid, extend=extend.right, xloc=xloc.bar_time)
                            array.push(cluster_lines, cluster_line)
                            
                            if show_offset_lines
                                offset_line_width = get_scaled_line_width(1)
                                
                                upper_line := line.new(start_time_line, upper_offset_level, end_time_line, upper_offset_level, color=cluster_color, width=offset_line_width, style=line.style_dashed, extend=extend.right, xloc=xloc.bar_time)
                                array.push(upper_offset_lines, upper_line)
                                
                                lower_line := line.new(start_time_line, lower_offset_level, end_time_line, lower_offset_level, color=cluster_color, width=offset_line_width, style=line.style_dashed, extend=extend.right, xloc=xloc.bar_time)
                                array.push(lower_offset_lines, lower_line)
                                
                                if show_fill
                                    fill_color = is_high ? color.new(#ffa500, 90) : color.new(#0000ff, 90)
                                    fill_obj := linefill.new(upper_line, lower_line, fill_color)
                                    array.push(offset_fills, fill_obj)
                            
                            if show_cluster_labels and barstate.islast
                                label_text = (is_high ? "HIGH " : "LOW ") + str.tostring(cluster_count)
                                label_color_text = is_high ? #ffa500 : #0000ff
                                label_offset_distance = get_label_offset_distance()
                                future_time = time + (time - time[1]) * label_offset_distance
                                label_size = get_scaled_label_size("small")
                                
                                cluster_label = label.new(future_time, avg_level, label_text, color=color.red, textcolor=label_color_text, style=label.style_label_center, yloc=yloc.price, size=label_size, xloc=xloc.bar_time)
                                array.push(cluster_labels, cluster_label)
                        
                        if enable_breakthrough_logic
                            update_breakthrough_data(level_id, avg_level, cluster_count, is_high, cluster_line, upper_line, lower_line, fill_obj)
                        
                        clusters_found += 1
            
            base_i := base_i + 1
        
        clusters_found

    // После блока find_clusters(), добавьте:
if enable_breakthrough_logic and array.size(active_clusters) > 0
    // Проверяем, есть ли кластеры без tracking'а
    for i = 0 to array.size(active_clusters) - 1
        cluster_data = array.get(active_clusters, i)
        existing_data = find_breakthrough_data(cluster_data.level_id)
        if na(existing_data)
            // Создаем tracking для пропущенного кластера с правильными типами
            var line dummy_cluster_line = na
            var line dummy_upper_line = na  
            var line dummy_lower_line = na
            var linefill dummy_fill = na
            
            update_breakthrough_data(cluster_data.level_id, cluster_data.avg_level, cluster_data.cluster_size, cluster_data.is_high, dummy_cluster_line, dummy_upper_line, dummy_lower_line, dummy_fill)


// ========== ОБРАБОТКА ЭКСТРЕМУМОВ ==========
current_scale := calculate_scale_parameters()

// Инициализация массивов алертов при первом запуске
if barstate.isfirst
    initialize_alert_arrays()

pivot_high = ta.pivothigh(high, leftBars, rightBars)
pivot_low = ta.pivotlow(low, leftBars, rightBars)

if not na(pivot_high)
    pivot_time = get_time_by_bar_index(bar_index - rightBars)
    new_high = ExtremumData.new(pivot_high, bar_index - rightBars, pivot_time, false)
    array.push(high_extremums, new_high)
    limit_array_size(high_extremums)
    
    pivot_label_size = get_scaled_label_size("tiny")
    label.new(bar_index - rightBars, pivot_high, "H", color=#008000, style=label.style_circle, size=pivot_label_size, textcolor=#ffffff)

if not na(pivot_low)
    pivot_time = get_time_by_bar_index(bar_index - rightBars)
    new_low = ExtremumData.new(pivot_low, bar_index - rightBars, pivot_time, false)
    array.push(low_extremums, new_low)
    limit_array_size(low_extremums)
    
    pivot_label_size = get_scaled_label_size("tiny")
    label.new(bar_index - rightBars, pivot_low, "L", color=#ffff00, style=label.style_circle, size=pivot_label_size, textcolor=#000000)

// ========== АБСОЛЮТНЫЕ ЭКСТРЕМУМЫ ==========
[absolute_high, absolute_low] = find_absolute_extremums()

if show_absolute_lines and barstate.islast
    lookback_time = get_time_by_bar_index(bar_index - math.min(lookback_bars, 1000))
    extension_distance = get_line_extension_distance()
    future_time = time + (time - time[1]) * extension_distance * 10
    
    abs_line_width = get_scaled_line_width(2)
    
    if not na(absolute_high_line)
        line.set_x1(absolute_high_line, lookback_time)
        line.set_x2(absolute_high_line, future_time)
        line.set_y1(absolute_high_line, absolute_high)
        line.set_y2(absolute_high_line, absolute_high)
        line.set_width(absolute_high_line, abs_line_width)
    else
        absolute_high_line := line.new(lookback_time, absolute_high, future_time, absolute_high, color=#0000ff, width=abs_line_width, extend=extend.both, xloc=xloc.bar_time)
    
    if not na(absolute_low_line)
        line.set_x1(absolute_low_line, lookback_time) 
        line.set_x2(absolute_low_line, future_time)
        line.set_y1(absolute_low_line, absolute_low) 
        line.set_y2(absolute_low_line, absolute_low)
        line.set_width(absolute_low_line, abs_line_width)
    else
        absolute_low_line := line.new(lookback_time, absolute_low, future_time, absolute_low, color=#ff0000, width=abs_line_width, extend=extend.both, xloc=xloc.bar_time)

// ========== ИСПРАВЛЕННАЯ ЛОГИКА ПЕРЕСЧЕТА ==========
recalc_condition = should_recalculate_clusters()

if recalc_condition and show_cluster_lines
    preserved_breakthrough_labels = array.new<label>()
    if array.size(breakthrough_labels) > 0
        for i = 0 to array.size(breakthrough_labels) - 1
            array.push(preserved_breakthrough_labels, array.get(breakthrough_labels, i))
    
    preserved_breakthroughs = preserve_breakthrough_data()
    
    clear_cluster_graphics_selectively()
    
    high_clusters = find_clusters(high_extremums, true)
    low_clusters = find_clusters(low_extremums, false)
    
    restore_breakthrough_data(preserved_breakthroughs)
    
    array.clear(breakthrough_labels)
    if array.size(preserved_breakthrough_labels) > 0
        for i = 0 to array.size(preserved_breakthrough_labels) - 1
            array.push(breakthrough_labels, array.get(preserved_breakthrough_labels, i))

// ========== ПРОВЕРКА КАСАНИЙ OFFSET ЛИНИЙ ==========
var bool high_upper_offset_alert = false
var bool high_lower_offset_alert = false
var bool low_upper_offset_alert = false
var bool low_lower_offset_alert = false

if enable_offset_alerts and array.size(active_clusters) > 0
    for i = 0 to array.size(active_clusters) - 1
        cluster_data = array.get(active_clusters, i)
        [upper_alert, lower_alert] = check_offset_touch(cluster_data)
        
        if upper_alert
            if cluster_data.is_high
                high_upper_offset_alert := true
            else
                low_upper_offset_alert := true
        
        if lower_alert
            if cluster_data.is_high
                high_lower_offset_alert := true
            else
                low_lower_offset_alert := true

// ========== УЛУЧШЕННАЯ ЛОГИКА ЗАПИЛОВ С ПРАВИЛЬНЫМ УДАЛЕНИЕМ ==========
// Замените существующий блок логики запилов этим исправленным вариантом:

if enable_breakthrough_logic and array.size(breakthrough_tracker) > 0
    indices_to_remove = array.new<int>()
    
    for i = 0 to array.size(breakthrough_tracker) - 1
        breakthrough_data = array.get(breakthrough_tracker, i)
        
        // Проверка подтверждения прорыва
        if breakthrough_data.is_pending and bar_index >= breakthrough_data.pending_check_bar
            confirmation_passed = false
            
            if breakthrough_data.is_high
                confirmation_passed := close > breakthrough_data.level_price
            else
                confirmation_passed := close < breakthrough_data.level_price
            
            if confirmation_passed
                breakthrough_data.breakthrough_count += 1
                breakthrough_data.is_pending := false
                
                create_breakthrough_label(breakthrough_data.level_price, breakthrough_data.cluster_size, breakthrough_data.is_high, breakthrough_data.breakthrough_count)
                
                // Установка алертов
                breakthrough_num = breakthrough_data.breakthrough_count
                if breakthrough_num <= max_breakthroughs
                    if breakthrough_data.is_high and breakthrough_num <= array.size(high_breakthrough_alerts)
                        array.set(high_breakthrough_alerts, breakthrough_num - 1, true)
                    else if not breakthrough_data.is_high and breakthrough_num <= array.size(low_breakthrough_alerts)
                        array.set(low_breakthrough_alerts, breakthrough_num - 1, true)
                
                // ИСПРАВЛЕНО: Удаление кластера после достижения максимального количества запилов
                if breakthrough_data.breakthrough_count >= max_breakthroughs
                    // Сначала скрываем/удаляем элементы
                    safe_hide_cluster_elements(breakthrough_data)
                    // Затем помечаем для удаления из breakthrough_tracker
                    array.push(indices_to_remove, i)
            else
                breakthrough_data.is_pending := false
        
        // Проверка нового прорыва только если кластер еще активен
        if not breakthrough_data.is_pending and breakthrough_data.breakthrough_count < max_breakthroughs
            level_crossed = check_level_breakthrough(breakthrough_data.level_price, breakthrough_data.is_high)
            
            if level_crossed
                breakthrough_data.is_pending := true
                breakthrough_data.pending_check_bar := bar_index + bars_offset
    
    // Удаляем обработанные прорывы из массива
    if array.size(indices_to_remove) > 0
        for i = array.size(indices_to_remove) - 1 to 0
            index_to_remove = array.get(indices_to_remove, i)
            array.remove(breakthrough_tracker, index_to_remove)

// ========== ОГРАНИЧЕНИЕ ГРАФИЧЕСКИХ ОБЪЕКТОВ ==========
if barstate.islast
    limit_graphics_objects()

// ========== ФИКСИРОВАННЫЕ АЛЕРТЫ ДЛЯ ВСЕХ ЗАПИЛОВ ==========
// Алерты для HIGH запилов (до 10 запилов)
alertcondition(array.size(high_breakthrough_alerts) > 0 ? array.get(high_breakthrough_alerts, 0) : false, title="1-й запил хай уровня", message="1-й запил хай уровня подтвержден!")
alertcondition(array.size(high_breakthrough_alerts) > 1 ? array.get(high_breakthrough_alerts, 1) : false, title="2-й запил хай уровня", message="2-й запил хай уровня подтвержден!")
alertcondition(array.size(high_breakthrough_alerts) > 2 ? array.get(high_breakthrough_alerts, 2) : false, title="3-й запил хай уровня", message="3-й запил хай уровня подтвержден!")
alertcondition(array.size(high_breakthrough_alerts) > 3 ? array.get(high_breakthrough_alerts, 3) : false, title="4-й запил хай уровня", message="4-й запил хай уровня подтвержден!")
alertcondition(array.size(high_breakthrough_alerts) > 4 ? array.get(high_breakthrough_alerts, 4) : false, title="5-й запил хай уровня", message="5-й запил хай уровня подтвержден!")
alertcondition(array.size(high_breakthrough_alerts) > 5 ? array.get(high_breakthrough_alerts, 5) : false, title="6-й запил хай уровня", message="6-й запил хай уровня подтвержден!")
alertcondition(array.size(high_breakthrough_alerts) > 6 ? array.get(high_breakthrough_alerts, 6) : false, title="7-й запил хай уровня", message="7-й запил хай уровня подтвержден!")
alertcondition(array.size(high_breakthrough_alerts) > 7 ? array.get(high_breakthrough_alerts, 7) : false, title="8-й запил хай уровня", message="8-й запил хай уровня подтвержден!")
alertcondition(array.size(high_breakthrough_alerts) > 8 ? array.get(high_breakthrough_alerts, 8) : false, title="9-й запил хай уровня", message="9-й запил хай уровня подтвержден!")
alertcondition(array.size(high_breakthrough_alerts) > 9 ? array.get(high_breakthrough_alerts, 9) : false, title="10-й запил хай уровня", message="10-й запил хай уровня подтвержден!")

// Алерты для LOW запилов (до 10 запилов)
alertcondition(array.size(low_breakthrough_alerts) > 0 ? array.get(low_breakthrough_alerts, 0) : false, title="1-й запил лоу уровня", message="1-й запил лоу уровня подтвержден!")
alertcondition(array.size(low_breakthrough_alerts) > 1 ? array.get(low_breakthrough_alerts, 1) : false, title="2-й запил лоу уровня", message="2-й запил лоу уровня подтвержден!")
alertcondition(array.size(low_breakthrough_alerts) > 2 ? array.get(low_breakthrough_alerts, 2) : false, title="3-й запил лоу уровня", message="3-й запил лоу уровня подтвержден!")
alertcondition(array.size(low_breakthrough_alerts) > 3 ? array.get(low_breakthrough_alerts, 3) : false, title="4-й запил лоу уровня", message="4-й запил лоу уровня подтвержден!")
alertcondition(array.size(low_breakthrough_alerts) > 4 ? array.get(low_breakthrough_alerts, 4) : false, title="5-й запил лоу уровня", message="5-й запил лоу уровня подтвержден!")
alertcondition(array.size(low_breakthrough_alerts) > 5 ? array.get(low_breakthrough_alerts, 5) : false, title="6-й запил лоу уровня", message="6-й запил лоу уровня подтвержден!")
alertcondition(array.size(low_breakthrough_alerts) > 6 ? array.get(low_breakthrough_alerts, 6) : false, title="7-й запил лоу уровня", message="7-й запил лоу уровня подтвержден!")
alertcondition(array.size(low_breakthrough_alerts) > 7 ? array.get(low_breakthrough_alerts, 7) : false, title="8-й запил лоу уровня", message="8-й запил лоу уровня подтвержден!")
alertcondition(array.size(low_breakthrough_alerts) > 8 ? array.get(low_breakthrough_alerts, 8) : false, title="9-й запил лоу уровня", message="9-й запил лоу уровня подтвержден!")
alertcondition(array.size(low_breakthrough_alerts) > 9 ? array.get(low_breakthrough_alerts, 9) : false, title="10-й запил лоу уровня", message="10-й запил лоу уровня подтвержден!")

// Алерты для касания offset линий
alertcondition(high_upper_offset_alert, title="Касание верхней offset линии хай кластера", message="Цена подходит к уровню хай кластера сверху")
alertcondition(high_lower_offset_alert, title="Касание нижней offset линии хай кластера", message="Цена подходит к уровню хай кластера снизу")
alertcondition(low_upper_offset_alert, title="Касание верхней offset линии лоу кластера", message="Цена подходит к уровню лоу кластера сверху")
alertcondition(low_lower_offset_alert, title="Касание нижней offset линии лоу кластера", message="Цена подходит к уровню лоу кластера снизу")

// ========== СБРОС АЛЕРТОВ ==========
if barstate.isconfirmed
    // Сброс алертов запилов
    for i = 0 to array.size(high_breakthrough_alerts) - 1
        array.set(high_breakthrough_alerts, i, false)
    for i = 0 to array.size(low_breakthrough_alerts) - 1
        array.set(low_breakthrough_alerts, i, false)
    
    high_upper_offset_alert := false
    high_lower_offset_alert := false
    low_upper_offset_alert := false
    low_lower_offset_alert := false

// ========== ОТЛАДОЧНАЯ ИНФОРМАЦИЯ ==========
if barstate.islast and auto_scale_enabled
    var table debug_table = table.new(position.top_right, 2, 7, bgcolor=color.white, border_width=1)
    
    if not na(current_scale)
        table.cell(debug_table, 0, 0, "Параметр", text_color=color.black, bgcolor=color.gray)
        table.cell(debug_table, 1, 0, "Значение", text_color=color.black, bgcolor=color.gray)
        
        table.cell(debug_table, 0, 1, "Диапазон цен", text_color=color.black)
        table.cell(debug_table, 1, 1, str.tostring(current_scale.price_range, "#.####"), text_color=color.black)
        
        table.cell(debug_table, 0, 2, "Видимые бары", text_color=color.black)
        table.cell(debug_table, 1, 2, str.tostring(current_scale.visible_bars), text_color=color.black)
        
        table.cell(debug_table, 0, 3, "Волатильность", text_color=color.black)
        table.cell(debug_table, 1, 3, str.tostring(current_scale.current_volatility * 100, "#.##") + "%", text_color=color.black)
        
        table.cell(debug_table, 0, 4, "Уровень зума", text_color=color.black)
        table.cell(debug_table, 1, 4, str.tostring(current_scale.zoom_level * 100, "#.##") + "%", text_color=color.black)
        
        table.cell(debug_table, 0, 5, "HIGH/LOW экстремумов", text_color=color.black)
        table.cell(debug_table, 1, 5, str.tostring(array.size(high_extremums)) + "/" + str.tostring(array.size(low_extremums)), text_color=color.black)
        
        table.cell(debug_table, 0, 6, "Макс. запилов для удаления", text_color=color.black)
        table.cell(debug_table, 1, 6, str.tostring(max_breakthroughs), text_color=color.black)

  // Отладочная информация для breakthrough tracking
if barstate.islast and enable_breakthrough_logic
    var table debug_breakthrough = table.new(position.bottom_left, 2, 6, bgcolor=color.white, border_width=1)
    
    table.cell(debug_breakthrough, 0, 0, "Параметр", text_color=color.black, bgcolor=color.gray)
    table.cell(debug_breakthrough, 1, 0, "Значение", text_color=color.black, bgcolor=color.gray)
    
    table.cell(debug_breakthrough, 0, 1, "Активных кластеров", text_color=color.black)
    table.cell(debug_breakthrough, 1, 1, str.tostring(array.size(active_clusters)), text_color=color.black)
    
    table.cell(debug_breakthrough, 0, 2, "Отслеживаемых прорывов", text_color=color.black)
    table.cell(debug_breakthrough, 1, 2, str.tostring(array.size(breakthrough_tracker)), text_color=color.black)
    
    table.cell(debug_breakthrough, 0, 3, "Max прорывов", text_color=color.black)
    table.cell(debug_breakthrough, 1, 3, str.tostring(max_breakthroughs), text_color=color.black)
    
    table.cell(debug_breakthrough, 0, 4, "Логика прорывов", text_color=color.black)
    table.cell(debug_breakthrough, 1, 4, enable_breakthrough_logic ? "ВКЛ" : "ВЫКЛ", text_color=color.black)
    
    // Показываем детали отслеживаемых прорывов
    details = ""
    if array.size(breakthrough_tracker) > 0
        for i = 0 to math.min(2, array.size(breakthrough_tracker) - 1)  // Показываем только первые 3
            data = array.get(breakthrough_tracker, i)
            details := details + (data.is_high ? "H:" : "L:") + str.tostring(data.breakthrough_count) + " "
    
    table.cell(debug_breakthrough, 0, 5, "Детали прорывов", text_color=color.black)
    table.cell(debug_breakthrough, 1, 5, details == "" ? "Нет данных" : details, text_color=color.black)